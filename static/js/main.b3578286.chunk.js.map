{"version":3,"sources":["components/Node/Node.js","components/NavigationBar/NavigationBar.js","components/Algorithms/Dijkstra.js","components/Algorithms/AStar.js","components/Algorithms/GreedyBestFirstSearch.js","components/Algorithms/BFS.js","components/Algorithms/DFS.js","containers/PathfindingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","isStart","isFinish","row","col","isWall","isWeighted","onMouseDown","onMouseUp","onMouseEnter","onMouseOut","extraClassName","id","className","Component","NavigationBar","algorithmOptions","key","text","value","obstacles","image","src","hideFixedMenu","setState","fixed","showFixedMenu","handleVisualize","e","onVisualizePressed","state","algorithm","obstacleCatcher","val","currentTarget","getElementsByTagName","innerHTML","onChoosingObstacle","algorithmCatcher","onChoosingAlgorithm","onClearPathPressed","onClearGridPressed","Menu","inverted","Container","Item","header","Dropdown","placeholder","fluid","selection","onChange","options","Button","variant","onClick","dijkstra","grid","startNode","finishNode","distance","visitedNodes","unVisitedNodes","nodes","push","getAllNodes","length","sort","nodeA","nodeB","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","node","unvisitedNeighbors","filter","getUnvisitedNeighbors","n","parentNode","curr","openList","neighbors","getOpenNeighbors","neighbor","gScore","g","best","inOpenList","h","Math","abs","f","bfs","queue","unshift","Main","visualize","inProgress","a","document","getElementById","afterPath","clearPath","startX","startY","finishX","finishY","visualizeDijkstra","visualizeAStar","visualizeGreedy","visualizeBFS","visualizeDFS","chooseAlgorithm","clearWeightedNodes","algo","chooseObstacle","obstacle","final","i","newNode","clearGrid","dragStart","dragEnd","mousePressed","getInitialGrid","newGrid","updatedGrid","j","setTimeout","window","alert","nodesInOrder","animateNoPath","animatePathNodes","reverse","getDijkstraPath","animateVisitedNodes","astar","ret","getAStarPath","getBFSPath","dfs","getDFSPath","greedyBFS","getGreedyBFSPath","onKeyDown","map","index","cur","slice","App","href","rel","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b3578286.chunk.js","sourcesContent":["import React from \"react\";\nimport { Component } from \"react\";\nimport \"./Node.css\";\nclass Node extends Component {\n\trender() {\n\t\tconst {\n\t\t\tisStart,\n\t\t\tisFinish,\n\t\t\trow,\n\t\t\tcol,\n\t\t\tisWall,\n\t\t\tisWeighted,\n\t\t\tonMouseDown,\n\t\t\tonMouseUp,\n\t\t\tonMouseEnter,\n\t\t\tonMouseOut,\n\t\t} = this.props;\n\t\tconst extraClassName = isFinish\n\t\t\t? \"finish\"\n\t\t\t: isStart\n\t\t\t? \"start\"\n\t\t\t: isWall\n\t\t\t? \"wall\"\n\t\t\t: isWeighted\n\t\t\t? \"weight\"\n\t\t\t: \"\";\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<td\n\t\t\t\t\tid={`node-${row}-${col}`}\n\t\t\t\t\tclassName={`node ${extraClassName} `}\n\t\t\t\t\tonMouseDown={() => onMouseDown(row, col)}\n\t\t\t\t\tonMouseEnter={() => onMouseEnter(row, col)}\n\t\t\t\t\tonMouseOut={() => onMouseOut(row, col)}\n\t\t\t\t\tonMouseUp={() => onMouseUp()}\n\t\t\t\t></td>\n\t\t\t</>\n\t\t);\n\t}\n}\n\nexport default Node;\n","import React, { Component } from \"react\";\nimport { Container, Dropdown, Menu, Button } from \"semantic-ui-react\";\nimport \"./NavigationBar.css\";\n\nexport default class NavigationBar extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\tfixed: false,\n\t\t\talgorithm: \"Algorithms\",\n\t\t};\n\t}\n\n\talgorithmOptions = [\n\t\t{\n\t\t\tkey: \"Dijkstra\",\n\t\t\ttext: \"Dijkstra\",\n\t\t\tvalue: \"Dijkstra\",\n\t\t},\n\t\t{\n\t\t\tkey: \"A* Search\",\n\t\t\ttext: \"A* Search\",\n\t\t\tvalue: \"A* Search\",\n\t\t},\n\t\t{\n\t\t\tkey: \"Greedy\",\n\t\t\ttext: \"Greedy Best First Search\",\n\t\t\tvalue: \"Greedy\",\n\t\t},\n\t\t{\n\t\t\tkey: \"BFS\",\n\t\t\ttext: \"Breadth First Search (BFS)\",\n\t\t\tvalue: \"BFS\",\n\t\t},\n\t\t{\n\t\t\tkey: \"DFS\",\n\t\t\ttext: \"Depth First Search (DFS)\",\n\t\t\tvalue: \"DFS\",\n\t\t},\n\t];\n\n\tobstacles = [\n\t\t{\n\t\t\tkey: \"Wall\",\n\t\t\ttext: \"Wall\",\n\t\t\tvalue: \"Wall\",\n\t\t\timage: { src: \"/wall.png\" },\n\t\t},\n\t\t{\n\t\t\tkey: \"Weighted Node\",\n\t\t\ttext: \"Weighted Node\",\n\t\t\tvalue: \"Weighted Node\",\n\t\t\timage: { src: \"/weight.svg\" },\n\t\t},\n\t];\n\n\thideFixedMenu = () => this.setState({ fixed: false });\n\tshowFixedMenu = () => this.setState({ fixed: true });\n\n\thandleVisualize = (e) => {\n\t\tthis.props.onVisualizePressed(this.state.algorithm);\n\t};\n\n\tobstacleCatcher = (e) => {\n\t\tlet val = e.currentTarget.getElementsByTagName(\"span\")[0].innerHTML;\n\t\tthis.props.onChoosingObstacle(val);\n\t};\n\n\talgorithmCatcher = (e) => {\n\t\tlet val = e.currentTarget.getElementsByTagName(\"span\")[0].innerHTML;\n\t\tthis.props.onChoosingAlgorithm(val);\n\t\tif (val === \"A* Search\") {\n\t\t\tval = \"A*\";\n\t\t} else if (val === \"Breadth First Search (BFS)\") {\n\t\t\tval = \"BFS\";\n\t\t} else if (val === \"Depth First Search (DFS)\") {\n\t\t\tval = \"DFS\";\n\t\t} else if (val === \"Greedy Best First Search\") {\n\t\t\tval = \"Greedy\";\n\t\t}\n\t\tthis.setState({ algorithm: val });\n\t};\n\t// #061830\n\trender() {\n\t\tconst { onClearPathPressed, onClearGridPressed } = this.props;\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<Menu fixed=\"top\" inverted id=\"navbar\">\n\t\t\t\t\t<Container>\n\t\t\t\t\t\t<Menu.Item header>\n\t\t\t\t\t\t\t<Dropdown\n\t\t\t\t\t\t\t\tplaceholder=\"Algorithms\"\n\t\t\t\t\t\t\t\tfluid\n\t\t\t\t\t\t\t\tselection\n\t\t\t\t\t\t\t\tid=\"algo\"\n\t\t\t\t\t\t\t\tonChange={this.algorithmCatcher}\n\t\t\t\t\t\t\t\toptions={this.algorithmOptions}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</Menu.Item>\n\t\t\t\t\t\t<Menu.Item header>\n\t\t\t\t\t\t\t<Dropdown\n\t\t\t\t\t\t\t\tplaceholder=\"Obstacles\"\n\t\t\t\t\t\t\t\tfluid\n\t\t\t\t\t\t\t\tselection\n\t\t\t\t\t\t\t\tid=\"walls\"\n\t\t\t\t\t\t\t\tonChange={this.obstacleCatcher}\n\t\t\t\t\t\t\t\toptions={this.obstacles}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</Menu.Item>\n\t\t\t\t\t\t<Menu.Item>\n\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\tid=\"button-visualize\"\n\t\t\t\t\t\t\t\tvariant=\"primary\"\n\t\t\t\t\t\t\t\tonClick={this.handleVisualize}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{this.state.algorithm === \"Algorithms\"\n\t\t\t\t\t\t\t\t\t? \"Pick An Algorithm\"\n\t\t\t\t\t\t\t\t\t: `Visualize ${this.state.algorithm} !`}\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t<Button id=\"button\" onClick={() => onClearPathPressed()}>\n\t\t\t\t\t\t\t\tClear Path\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t<Button id=\"button\" onClick={() => onClearGridPressed()}>\n\t\t\t\t\t\t\t\tClear Grid\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t</Menu.Item>\n\t\t\t\t\t</Container>\n\t\t\t\t</Menu>\n\t\t\t</>\n\t\t);\n\t}\n}\n","export function dijkstra(grid, startNode, finishNode) {\n\tstartNode.distance = 0;\n\tconst visitedNodes = [];\n\tconst unVisitedNodes = getAllNodes(grid);\n\twhile (unVisitedNodes.length) {\n\t\tsortNodesByDistance(unVisitedNodes);\n\t\tconst closestNode = unVisitedNodes.shift();\n\t\tif (closestNode.isWall) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (closestNode.distance === Infinity) {\n\t\t\treturn visitedNodes;\n\t\t}\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodes.push(closestNode);\n\t\tif (closestNode === finishNode) {\n\t\t\treturn visitedNodes;\n\t\t}\n\t\tupdateUnvisitedNeighbors(grid, closestNode);\n\t}\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n\tunvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(grid, node) {\n\tconst unvisitedNeighbors = getUnvisitedNeighbors(grid, node.row, node.col);\n\tfor (let n of unvisitedNeighbors) {\n\t\tn.distance = node.distance + (n.isWeighted ? 15 : 1);\n\t\tn.parentNode = node;\n\t}\n}\n\nfunction getUnvisitedNeighbors(grid, row, col) {\n\tconst nodes = [];\n\tif (row > 0) nodes.push(grid[row - 1][col]);\n\tif (col > 0) nodes.push(grid[row][col - 1]);\n\tif (row < grid.length - 1) nodes.push(grid[row + 1][col]);\n\tif (col < grid[0].length - 1) nodes.push(grid[row][col + 1]);\n\t// if (col < grid[0].length - 2) nodes.push(grid[row][col + 2]);\n\treturn nodes.filter((node) => !node.isVisited);\n}\n\nfunction getAllNodes(grid) {\n\tconst nodes = [];\n\tfor (let row of grid) {\n\t\tfor (let col of row) {\n\t\t\tnodes.push(col);\n\t\t}\n\t}\n\treturn nodes;\n}\n\nexport function getDijkstraPath(finishNode) {\n\tconst nodes = [];\n\tconst node = finishNode;\n\twhile (finishNode.parentNode) {\n\t\tnodes.push(finishNode);\n\t\tfinishNode = finishNode.parentNode;\n\t}\n\tif (node !== finishNode) nodes.push(finishNode);\n\tnodes.reverse();\n\treturn nodes;\n}\n","export function astar(grid, startNode, finishNode) {\n\tvar visitedNodes = [];\n\tvar openList = [];\n\tstartNode.f = 0;\n\topenList.push(startNode);\n\n\twhile (openList.length > 0) {\n\t\tsortNodesByFScore(openList);\n\t\tconst curr = openList.shift();\n\t\tif (curr.isWall === true) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (curr.f === Infinity) {\n\t\t\treturn visitedNodes;\n\t\t}\n\t\tcurr.isVisited = true;\n\t\tvisitedNodes.push(curr);\n\t\tif (curr === finishNode) {\n\t\t\treturn visitedNodes;\n\t\t}\n\t\tupdateUnvisitedNeighbors(grid, curr, openList, finishNode);\n\t}\n\treturn visitedNodes;\n}\n\nfunction sortNodesByFScore(openNodes) {\n\topenNodes.sort((nodeA, nodeB) => nodeA.f - nodeB.f);\n}\n\n// Manhattan Distance\nfunction heuristic(nodeA, nodeB) {\n\tvar d1 = Math.abs(nodeA.row - nodeB.row);\n\tvar d2 = Math.abs(nodeA.col - nodeB.col);\n\treturn d1 + d2;\n}\n\nfunction updateUnvisitedNeighbors(grid, curr, openList, finishNode) {\n\tvar neighbors = getOpenNeighbors(grid, curr.row, curr.col);\n\tfor (let neighbor of neighbors) {\n\t\tvar gScore = curr.g + (neighbor.isWeighted ? 15 : 1);\n\t\tvar best = false;\n\t\tvar inOpenList = false;\n\t\tfor (let node of openList) {\n\t\t\tif (node === neighbor) {\n\t\t\t\tinOpenList = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!inOpenList) {\n\t\t\tbest = true;\n\t\t\tneighbor.h = heuristic(neighbor, finishNode);\n\t\t\topenList.push(neighbor);\n\t\t} else if (gScore < neighbor.g) {\n\t\t\tbest = true;\n\t\t}\n\t\tif (best) {\n\t\t\tneighbor.parentNode = curr;\n\t\t\tneighbor.g = gScore;\n\t\t\tneighbor.f = neighbor.g + neighbor.h;\n\t\t}\n\t}\n}\n\nfunction getOpenNeighbors(grid, row, col) {\n\tconst nodes = [];\n\tif (row > 0) nodes.push(grid[row - 1][col]);\n\tif (col > 0) nodes.push(grid[row][col - 1]);\n\tif (row < grid.length - 1) nodes.push(grid[row + 1][col]);\n\tif (col < grid[0].length - 1) nodes.push(grid[row][col + 1]);\n\t// if (row > 0 && col > 0) nodes.push(grid[row - 1][col - 1]);\n\t// if (row < grid.length - 1 && col < grid[0].length - 1)\n\t// \tnodes.push(grid[row + 1][col + 1]);\n\t// if (row > 0 && col < grid[0].length - 1) nodes.push(grid[row - 1][col + 1]);\n\t// if (row < grid.length - 1 && col > 0) nodes.push(grid[row + 1][col - 1]);\n\treturn nodes.filter((node) => !node.isVisited && !node.isWall);\n}\n\nexport function getAStarPath(finishNode) {\n\tvar curr = finishNode;\n\tvar ret = [];\n\twhile (curr.parentNode) {\n\t\tret.push(curr);\n\t\tcurr = curr.parentNode;\n\t}\n\tif (curr !== finishNode) ret.push(curr);\n\treturn ret.reverse();\n}\n","export function greedyBFS(grid, startNode, finishNode) {\n\tvar visitedNodes = [];\n\tvar openList = [];\n\tstartNode.f = 0;\n\topenList.push(startNode);\n\n\twhile (openList.length > 0) {\n\t\tsortNodesByFScore(openList);\n\t\tconst curr = openList.shift();\n\t\tif (curr.isWall === true) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (curr.f === Infinity) {\n\t\t\treturn visitedNodes;\n\t\t}\n\t\tcurr.isVisited = true;\n\t\tvisitedNodes.push(curr);\n\t\tif (curr === finishNode) {\n\t\t\treturn visitedNodes;\n\t\t}\n\t\tupdateUnvisitedNeighbors(grid, curr, openList, finishNode);\n\t}\n\treturn visitedNodes;\n}\n\nfunction sortNodesByFScore(openNodes) {\n\topenNodes.sort((nodeA, nodeB) => nodeA.f - nodeB.f);\n}\n\n// Manhattan Distance\nfunction heuristic(nodeA, nodeB) {\n\tvar d1 = Math.abs(nodeA.row - nodeB.row);\n\tvar d2 = Math.abs(nodeA.col - nodeB.col);\n\treturn d1 + d2;\n}\n\nfunction updateUnvisitedNeighbors(grid, curr, openList, finishNode) {\n\tvar neighbors = getOpenNeighbors(grid, curr.row, curr.col);\n\tfor (let neighbor of neighbors) {\n\t\tvar inOpenList = false;\n\t\tvar best = false;\n\t\tfor (let node of openList) {\n\t\t\tif (node === neighbor) {\n\t\t\t\tinOpenList = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!inOpenList) {\n\t\t\tbest = true;\n\t\t\tneighbor.h =\n\t\t\t\theuristic(neighbor, finishNode) + (neighbor.isWeighted ? 15 : 0);\n\t\t\topenList.push(neighbor);\n\t\t}\n\t\tif (best) {\n\t\t\tneighbor.parentNode = curr;\n\t\t\tneighbor.f = neighbor.h;\n\t\t}\n\t}\n}\n\nfunction getOpenNeighbors(grid, row, col) {\n\tconst nodes = [];\n\tif (row > 0) nodes.push(grid[row - 1][col]);\n\tif (col > 0) nodes.push(grid[row][col - 1]);\n\tif (row < grid.length - 1) nodes.push(grid[row + 1][col]);\n\tif (col < grid[0].length - 1) nodes.push(grid[row][col + 1]);\n\t// if (row < grid.length - 1 && col < grid[0].length - 1)\n\t// \tnodes.push(grid[row + 1][col + 1]);\n\t// if (row > 0 && col < grid[0].length - 1) nodes.push(grid[row - 1][col + 1]);\n\t// if (row < grid.length - 1 && col > 0) nodes.push(grid[row + 1][col - 1]);\n\treturn nodes.filter((node) => !node.isVisited && !node.isWall);\n}\n\nexport function getGreedyBFSPath(finishNode) {\n\tvar curr = finishNode;\n\tvar ret = [];\n\twhile (curr.parentNode) {\n\t\tret.push(curr);\n\t\tcurr = curr.parentNode;\n\t}\n\tif (curr !== finishNode) ret.push(curr);\n\treturn ret.reverse();\n}\n","export function bfs(grid, startNode, finishNode) {\n\tstartNode.distance = 0;\n\tconst visitedNodes = [];\n\tconst unVisitedNodes = getAllNodes(grid);\n\twhile (unVisitedNodes.length) {\n\t\tsortNodesByDistance(unVisitedNodes);\n\t\tconst closestNode = unVisitedNodes.shift();\n\t\tif (closestNode.isWall) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (closestNode.distance === Infinity) {\n\t\t\treturn visitedNodes;\n\t\t}\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodes.push(closestNode);\n\t\tif (closestNode === finishNode) {\n\t\t\treturn visitedNodes;\n\t\t}\n\t\tupdateUnvisitedNeighbors(grid, closestNode);\n\t}\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n\tunvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(grid, node) {\n\tconst unvisitedNeighbors = getUnvisitedNeighbors(grid, node.row, node.col);\n\tfor (let n of unvisitedNeighbors) {\n\t\tn.distance = node.distance + 1;\n\t\tn.parentNode = node;\n\t}\n}\n\nfunction getUnvisitedNeighbors(grid, row, col) {\n\tconst nodes = [];\n\tif (row > 0) nodes.push(grid[row - 1][col]);\n\tif (col > 0) nodes.push(grid[row][col - 1]);\n\tif (row < grid.length - 1) nodes.push(grid[row + 1][col]);\n\tif (col < grid[0].length - 1) nodes.push(grid[row][col + 1]);\n\treturn nodes.filter((node) => !node.isVisited);\n}\n\nfunction getAllNodes(grid) {\n\tconst nodes = [];\n\tfor (let row of grid) {\n\t\tfor (let col of row) {\n\t\t\tnodes.push(col);\n\t\t}\n\t}\n\treturn nodes;\n}\n\nexport function getBFSPath(finishNode) {\n\tconst nodes = [];\n\tconst node = finishNode;\n\twhile (finishNode.parentNode) {\n\t\tnodes.push(finishNode);\n\t\tfinishNode = finishNode.parentNode;\n\t}\n\tif (node !== finishNode) nodes.push(finishNode);\n\tnodes.reverse();\n\treturn nodes;\n}\n","export function dfs(grid, startNode, finishNode) {\n\tstartNode.distance = 0;\n\tconst visitedNodes = [];\n\tconst queue = [];\n\tqueue.push(startNode);\n\twhile (queue.length) {\n\t\tconst closestNode = queue.shift();\n\t\tif (closestNode.isWall) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (closestNode.distance === Infinity) {\n\t\t\treturn visitedNodes;\n\t\t}\n\t\tif (closestNode.isVisited) {\n\t\t\tcontinue;\n\t\t}\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodes.push(closestNode);\n\t\tif (closestNode === finishNode) {\n\t\t\treturn visitedNodes;\n\t\t}\n\t\tupdateUnvisitedNeighbors(grid, closestNode, queue);\n\t}\n\treturn visitedNodes;\n}\n\nfunction updateUnvisitedNeighbors(grid, node, queue) {\n\tconst unvisitedNeighbors = getUnvisitedNeighbors(grid, node.row, node.col);\n\tfor (let n of unvisitedNeighbors) {\n\t\tqueue.unshift(n);\n\t\tn.distance = node.distance + 1;\n\t\tn.parentNode = node;\n\t}\n}\n\nfunction getUnvisitedNeighbors(grid, row, col) {\n\tconst nodes = [];\n\tif (col > 0) nodes.push(grid[row][col - 1]);\n\tif (row > 0) nodes.push(grid[row - 1][col]);\n\tif (col < grid[0].length - 1) nodes.push(grid[row][col + 1]);\n\tif (row < grid.length - 1) nodes.push(grid[row + 1][col]);\n\treturn nodes.filter((node) => !node.isVisited && !node.isWall);\n}\n\nexport function getDFSPath(finishNode) {\n\tconst nodes = [];\n\tconst node = finishNode;\n\twhile (finishNode.parentNode) {\n\t\tnodes.push(finishNode);\n\t\tfinishNode = finishNode.parentNode;\n\t}\n\tif (node !== finishNode) nodes.push(finishNode);\n\tnodes.reverse();\n\treturn nodes;\n}\n","import React, { Component } from \"react\";\nimport Node from \"../components/Node/Node\";\nimport NavigationBar from \"../components/NavigationBar/NavigationBar\";\nimport { dijkstra, getDijkstraPath } from \"../components/Algorithms/Dijkstra\";\nimport { astar, getAStarPath } from \"../components/Algorithms/AStar\";\nimport {\n\tgreedyBFS,\n\tgetGreedyBFSPath,\n} from \"../components/Algorithms/GreedyBestFirstSearch\";\nimport { bfs, getBFSPath } from \"../components/Algorithms/BFS\";\nimport { dfs, getDFSPath } from \"../components/Algorithms/DFS\";\nimport \"./PathfindingVisualizer.css\";\n\nexport default class Main extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\tgrid: [],\n\t\t\tdragStart: false,\n\t\t\tdragEnd: false,\n\t\t\tmousePressed: false,\n\t\t\tobstacle: \"Wall\",\n\t\t\tstartX: 14,\n\t\t\tstartY: 15,\n\t\t\tfinishX: 14,\n\t\t\tfinishY: 55,\n\t\t\tinProgress: false,\n\t\t\tafterPath: false,\n\t\t\talgo: \"\",\n\t\t};\n\t}\n\n\tcomponentDidMount() {\n\t\tconst final = this.getInitialGrid();\n\t\tthis.setState({ grid: final });\n\t}\n\n\tonMouseDown(row, col) {\n\t\tif (this.state.inProgress || this.state.afterPath) {\n\t\t\treturn;\n\t\t}\n\t\tconst { grid } = this.state;\n\t\tif (grid[row][col].isStart) {\n\t\t\tthis.setState({\n\t\t\t\tmousePressed: true,\n\t\t\t\tdragStart: true,\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (grid[row][col].isFinish) {\n\t\t\tthis.setState({\n\t\t\t\tmousePressed: true,\n\t\t\t\tdragEnd: true,\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tconst newGrid = this.updatedGrid(this.state.grid, row, col);\n\t\tthis.setState({ grid: newGrid, mousePressed: true });\n\t}\n\n\tonMouseEnter(row, col) {\n\t\tconst { grid } = this.state;\n\t\tif (this.state.inProgress || this.state.afterPath) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this.state.mousePressed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.state.dragStart) {\n\t\t\tconst newGrid = grid;\n\t\t\tnewGrid[row][col].isStart = !grid[row][col].isStart;\n\t\t\tnewGrid[row][col].isWall = false;\n\t\t\tnewGrid[row][col].isWeighted = false;\n\t\t\tthis.setState({ grid: newGrid, startX: row, startY: col });\n\t\t\treturn;\n\t\t}\n\t\tif (this.state.dragEnd) {\n\t\t\tconst newGrid = grid;\n\t\t\tnewGrid[row][col].isWeighted = false;\n\t\t\tnewGrid[row][col].isWall = false;\n\t\t\tnewGrid[row][col].isFinish = !grid[row][col].isFinish;\n\t\t\tthis.setState({\n\t\t\t\tgrid: newGrid,\n\t\t\t\tfinishX: row,\n\t\t\t\tfinishY: col,\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (grid[row][col].isStart || grid[row][col].isFinish) {\n\t\t\treturn;\n\t\t}\n\t\tconst newGrid = this.updatedGrid(this.state.grid, row, col);\n\t\tthis.setState({ grid: newGrid });\n\t}\n\n\tonMouseOut(row, col) {\n\t\tif (this.state.inProgress || this.state.afterPath) {\n\t\t\treturn;\n\t\t}\n\t\tconst { grid } = this.state;\n\t\tif (!this.state.mousePressed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.state.dragStart) {\n\t\t\tconst newGrid = grid;\n\t\t\tnewGrid[row][col].isStart = !grid[row][col].isStart;\n\t\t\tthis.setState({ grid: newGrid, startX: row, startY: col });\n\t\t\treturn;\n\t\t}\n\t\tif (this.state.dragEnd) {\n\t\t\tconst newGrid = grid;\n\t\t\tnewGrid[row][col].isFinish = !grid[row][col].isFinish;\n\t\t\tthis.setState({\n\t\t\t\tgrid: newGrid,\n\t\t\t\tfinishX: row,\n\t\t\t\tfinishY: col,\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t}\n\n\tonMouseUp(row, col) {\n\t\tif (this.state.inProgress || this.state.afterPath) {\n\t\t\treturn;\n\t\t}\n\t\tthis.setState({ dragStart: false, dragEnd: false, mousePressed: false });\n\t}\n\n\tanimateNoPath() {\n\t\tfor (let i = 0; i < 30; i++) {\n\t\t\tfor (let j = 0; j < 70; j++) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.state.grid[i][j].isVisited &&\n\t\t\t\t\t\t!this.state.grid[i][j].isFinish &&\n\t\t\t\t\t\t!this.state.grid[i][j].isStart &&\n\t\t\t\t\t\t!this.state.grid[i][j].isWall &&\n\t\t\t\t\t\t!this.state.grid[i][j].isWeighted\n\t\t\t\t\t)\n\t\t\t\t\t\tdocument.getElementById(`node-${i}-${j}`).className = \"node nopath\";\n\t\t\t\t}, 40 * i + 40 * j);\n\t\t\t}\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (i === 29) window.alert(\"No Path Found :(\");\n\t\t\t}, 4500);\n\t\t}\n\t}\n\n\tanimatePathNodes(nodesInOrder) {\n\t\tif (nodesInOrder.length === 0) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.animateNoPath();\n\t\t\t}, 2000);\n\t\t\tthis.setState({ inProgress: false, afterPath: true });\n\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i <= nodesInOrder.length; i++) {\n\t\t\tif (i === nodesInOrder.length) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.setState({ inProgress: false, afterPath: true });\n\t\t\t\t}, 30 * i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = nodesInOrder[i];\n\t\t\t\tif (!node.isStart && !node.isFinish && !node.isWeighted)\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node inpath\";\n\t\t\t\telse if (node.isStart) {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node startSpecial\";\n\t\t\t\t} else if (node.isFinish) {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node finishSpecial\";\n\t\t\t\t} else {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node weightSpecial\";\n\t\t\t\t}\n\t\t\t}, 30 * i);\n\t\t}\n\t}\n\n\tanimateVisitedNodes(visitedNodes, nodesInOrder) {\n\t\tfor (let i = 0; i <= visitedNodes.length; i++) {\n\t\t\tif (i === visitedNodes.length) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.animatePathNodes(nodesInOrder);\n\t\t\t\t}, 10 * i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = visitedNodes[i];\n\t\t\t\tif (!node.isStart && !node.isFinish && !node.isWeighted)\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node visited\";\n\t\t\t\telse if (node.isStart) {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node visitedStart\";\n\t\t\t\t} else if (node.isFinish) {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node visitedFinish\";\n\t\t\t\t} else {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node visitedWeight\";\n\t\t\t\t}\n\t\t\t}, 10 * i);\n\t\t}\n\t}\n\n\tvisualizeDijkstra(grid, startNode, finishNode) {\n\t\tconst visitedNodes = dijkstra(grid, startNode, finishNode);\n\t\tconst nodesInOrder = getDijkstraPath(finishNode);\n\t\tthis.animateVisitedNodes(visitedNodes, nodesInOrder);\n\t}\n\n\tvisualizeAStar(grid, startNode, finishNode) {\n\t\tconst visitedNodes = astar(grid, startNode, finishNode);\n\t\tconst nodesInOrder = getAStarPath(finishNode);\n\t\tthis.animateVisitedNodes(visitedNodes, nodesInOrder);\n\t}\n\n\tvisualizeBFS(grid, startNode, finishNode) {\n\t\tconst visitedNodes = bfs(grid, startNode, finishNode);\n\t\tconst nodesInOrder = getBFSPath(finishNode);\n\t\tthis.animateVisitedNodes(visitedNodes, nodesInOrder);\n\t}\n\n\tvisualizeDFS(grid, startNode, finishNode) {\n\t\tconst visitedNodes = dfs(grid, startNode, finishNode);\n\t\tconst nodesInOrder = getDFSPath(finishNode);\n\t\tthis.animateVisitedNodes(visitedNodes, nodesInOrder);\n\t}\n\n\tvisualizeGreedy(grid, startNode, finishNode) {\n\t\tconst visitedNodes = greedyBFS(grid, startNode, finishNode);\n\t\tconst nodesInOrder = getGreedyBFSPath(finishNode);\n\t\tthis.animateVisitedNodes(visitedNodes, nodesInOrder);\n\t}\n\n\tvisualize = (algorithm) => {\n\t\tif (this.state.inProgress) {\n\t\t\treturn;\n\t\t}\n\t\tvar a = document.getElementById(\"info\");\n\t\tif (algorithm === \"Algorithms\") {\n\t\t\ta.innerHTML = \"Please choose an algorithm to visualize\";\n\t\t\treturn;\n\t\t}\n\t\tthis.setState({ inProgress: true });\n\t\tif (this.state.afterPath) {\n\t\t\tthis.clearPath();\n\t\t}\n\t\tvar { grid, startX, startY, finishX, finishY } = this.state;\n\n\t\tvar startNode = grid[startX][startY];\n\t\tvar finishNode = grid[finishX][finishY];\n\t\tif (algorithm === \"Dijkstra\") {\n\t\t\tthis.visualizeDijkstra(grid, startNode, finishNode);\n\t\t} else if (algorithm === \"A*\") {\n\t\t\tthis.visualizeAStar(grid, startNode, finishNode);\n\t\t} else if (algorithm === \"Greedy\") {\n\t\t\tthis.visualizeGreedy(grid, startNode, finishNode);\n\t\t} else if (algorithm === \"BFS\") {\n\t\t\tthis.visualizeBFS(grid, startNode, finishNode);\n\t\t} else if (algorithm === \"DFS\") {\n\t\t\tthis.visualizeDFS(grid, startNode, finishNode);\n\t\t}\n\t};\n\n\tchooseAlgorithm = (algorithm) => {\n\t\tvar a = document.getElementById(\"info\");\n\t\tif (algorithm === \"Dijkstra\") {\n\t\t\talgorithm = \"W\";\n\t\t\ta.innerHTML =\n\t\t\t\t\"Dijkstra's Algorithm is <i>weighted</i> and <i>guarantees</i> the shortest path!\";\n\t\t} else if (algorithm === \"A* Search\") {\n\t\t\talgorithm = \"W\";\n\t\t\ta.innerHTML =\n\t\t\t\t\"A* Search is <i>weighted</i> and <i>guarantees</i> the shortest path!\";\n\t\t} else if (algorithm === \"Greedy Best First Search\") {\n\t\t\talgorithm = \"W\";\n\t\t\ta.innerHTML =\n\t\t\t\t\"Greedy Best First Search is <i>weighted</i> and <i>does not guarantee</i> the shortest path!\";\n\t\t} else if (algorithm === \"Breadth First Search (BFS)\") {\n\t\t\talgorithm = \"U\";\n\t\t\tthis.clearWeightedNodes();\n\t\t\ta.innerHTML =\n\t\t\t\t\"Breath First Search is <i>unweighted</i> and <i>guarantees</i> the shortest path!\";\n\t\t} else if (algorithm === \"Depth First Search (DFS)\") {\n\t\t\talgorithm = \"U\";\n\t\t\tthis.clearWeightedNodes();\n\t\t\ta.innerHTML =\n\t\t\t\t\"Depth First Search is <i>unweighted</i> and <i>does not guarantee</i> the shortest path!\";\n\t\t}\n\t\tthis.setState({ algo: algorithm });\n\t};\n\n\tchooseObstacle = (val) => {\n\t\tthis.setState({ obstacle: val });\n\t};\n\n\trender() {\n\t\tconst { grid } = this.state;\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<NavigationBar\n\t\t\t\t\tonVisualizePressed={this.visualize}\n\t\t\t\t\tonClearPathPressed={this.clearPath}\n\t\t\t\t\tonClearGridPressed={this.clearGrid}\n\t\t\t\t\tonChoosingAlgorithm={this.chooseAlgorithm}\n\t\t\t\t\tonChoosingObstacle={this.chooseObstacle}\n\t\t\t\t/>\n\t\t\t\t<div className=\"grid\" onKeyDown={this.onKeyDown}>\n\t\t\t\t\t<h3 id=\"info\">Please choose an algorithm to visualize</h3>\n\t\t\t\t\t<table>\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t{grid.map((row, index) => {\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<tr key={index}>\n\t\t\t\t\t\t\t\t\t\t{row.map((node, index) => {\n\t\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t\t<Node\n\t\t\t\t\t\t\t\t\t\t\t\t\tkey={index}\n\t\t\t\t\t\t\t\t\t\t\t\t\trow={node.row}\n\t\t\t\t\t\t\t\t\t\t\t\t\tcol={node.col}\n\t\t\t\t\t\t\t\t\t\t\t\t\tisStart={node.isStart}\n\t\t\t\t\t\t\t\t\t\t\t\t\tisFinish={node.isFinish}\n\t\t\t\t\t\t\t\t\t\t\t\t\tisWall={node.isWall}\n\t\t\t\t\t\t\t\t\t\t\t\t\tisWeighted={node.isWeighted}\n\t\t\t\t\t\t\t\t\t\t\t\t\tonMouseDown={(row, col) => this.onMouseDown(row, col)}\n\t\t\t\t\t\t\t\t\t\t\t\t\tonMouseEnter={(row, col) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.onMouseEnter(row, col)\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tonMouseUp={() => this.onMouseUp()}\n\t\t\t\t\t\t\t\t\t\t\t\t\tonMouseOut={(row, col) => this.onMouseOut(row, col)}\n\t\t\t\t\t\t\t\t\t\t\t\t></Node>\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\t\t\t\t</div>\n\t\t\t</>\n\t\t);\n\t}\n\n\tgetInitialGrid() {\n\t\tvar final = [];\n\t\tconst { startX, startY, finishX, finishY } = this.state;\n\t\tfor (let i = 0; i < 30; i++) {\n\t\t\tvar cur = [];\n\t\t\tfor (let j = 0; j < 70; j++) {\n\t\t\t\tconst node = {\n\t\t\t\t\trow: i,\n\t\t\t\t\tcol: j,\n\t\t\t\t\tisStart: i === startX && j === startY,\n\t\t\t\t\tisFinish: i === finishX && j === finishY,\n\t\t\t\t\tisWeighted: false,\n\t\t\t\t\tdistance: Infinity,\n\t\t\t\t\tisVisited: false,\n\t\t\t\t\tisWall: false,\n\t\t\t\t\tparentNode: null,\n\t\t\t\t\tf: Infinity,\n\t\t\t\t\tg: 0,\n\t\t\t\t\th: Infinity,\n\t\t\t\t};\n\t\t\t\tcur.push(node);\n\t\t\t}\n\t\t\tfinal.push(cur);\n\t\t}\n\t\treturn final;\n\t}\n\n\tclearWeightedNodes() {\n\t\tconst { grid } = this.state;\n\t\tvar final = grid;\n\t\tfor (let row of final) {\n\t\t\tfor (let i = 0; i < row.length; i++) {\n\t\t\t\tconst node = row[i];\n\t\t\t\tif (node.isWeighted) {\n\t\t\t\t\tconst newNode = {\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\tisWeighted: false,\n\t\t\t\t\t};\n\t\t\t\t\tif (!newNode.isStart && !newNode.isFinish)\n\t\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\t\"node\";\n\t\t\t\t\trow[i] = newNode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.setState({ grid: final });\n\t}\n\n\tclearPath = () => {\n\t\tif (this.state.inProgress) {\n\t\t\treturn;\n\t\t}\n\t\tconst { grid } = this.state;\n\t\tvar final = grid;\n\t\tfor (let row of final) {\n\t\t\tfor (let i = 0; i < row.length; i++) {\n\t\t\t\tconst node = row[i];\n\t\t\t\tconst newNode = {\n\t\t\t\t\t...node,\n\t\t\t\t\tdistance: Infinity,\n\t\t\t\t\tisVisited: false,\n\t\t\t\t\tparentNode: null,\n\t\t\t\t\tf: Infinity,\n\t\t\t\t\tg: 0,\n\t\t\t\t\th: Infinity,\n\t\t\t\t};\n\t\t\t\tif (\n\t\t\t\t\t!newNode.isStart &&\n\t\t\t\t\t!newNode.isFinish &&\n\t\t\t\t\t!newNode.isWall &&\n\t\t\t\t\t!newNode.isWeighted\n\t\t\t\t)\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node\";\n\t\t\t\telse if (newNode.isStart) {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node start\";\n\t\t\t\t} else if (newNode.isFinish) {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node finish\";\n\t\t\t\t} else if (newNode.isWall) {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node wall\";\n\t\t\t\t} else {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node weight\";\n\t\t\t\t}\n\t\t\t\trow[i] = newNode;\n\t\t\t}\n\t\t}\n\t\tthis.setState({ grid: final, afterPath: false });\n\t};\n\n\tclearGrid = () => {\n\t\tif (this.state.inProgress) {\n\t\t\treturn;\n\t\t}\n\t\tconst { grid } = this.state;\n\t\tvar final = grid;\n\t\tfor (let row of final) {\n\t\t\tfor (let i = 0; i < row.length; i++) {\n\t\t\t\tconst node = row[i];\n\t\t\t\tconst newNode = {\n\t\t\t\t\t...node,\n\t\t\t\t\tdistance: Infinity,\n\t\t\t\t\tisVisited: false,\n\t\t\t\t\tisWall: false,\n\t\t\t\t\tisWeighted: false,\n\t\t\t\t\tparentNode: null,\n\t\t\t\t\tf: Infinity,\n\t\t\t\t\tg: 0,\n\t\t\t\t\th: Infinity,\n\t\t\t\t};\n\t\t\t\tif (!newNode.isStart && !newNode.isFinish)\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node\";\n\t\t\t\telse if (newNode.isStart) {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node start\";\n\t\t\t\t} else {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node finish\";\n\t\t\t\t}\n\t\t\t\trow[i] = newNode;\n\t\t\t}\n\t\t}\n\t\tthis.setState({ grid: final, afterPath: false });\n\t};\n\n\tupdatedGrid(grid, row, col) {\n\t\tconst newGrid = grid.slice();\n\t\tconst node = grid[row][col];\n\t\tif (this.state.obstacle === \"Wall\") {\n\t\t\tif (node.isWeighted) {\n\t\t\t\tnode.isWeighted = false;\n\t\t\t}\n\t\t\tconst newNode = {\n\t\t\t\t...node,\n\t\t\t\tisWall: !node.isWall,\n\t\t\t};\n\t\t\tnewGrid[row][col] = newNode;\n\t\t\treturn newGrid;\n\t\t} else {\n\t\t\tif (this.state.algo === \"U\") {\n\t\t\t\treturn grid;\n\t\t\t}\n\t\t\tif (node.isWall) {\n\t\t\t\tnode.isWall = false;\n\t\t\t}\n\t\t\tconst newNode = {\n\t\t\t\t...node,\n\t\t\t\tisWeighted: !node.isWeighted,\n\t\t\t};\n\t\t\tnewGrid[row][col] = newNode;\n\t\t\treturn newGrid;\n\t\t}\n\t}\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./containers/PathfindingVisualizer\";\n// import \"bootstrap/dist/css/bootstrap.min.css\";\n\nfunction App() {\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<link\n\t\t\t\thref=\"https://fonts.googleapis.com/css2?family=Merriweather&family=Nanum+Myeongjo:wght@700&family=PT+Serif&display=swap\"\n\t\t\t\trel=\"stylesheet\"\n\t\t\t></link>\n\t\t\t<link\n\t\t\t\thref=\"https://fonts.googleapis.com/css2?family=Open+Sans:wght@600&display=swap\"\n\t\t\t\trel=\"stylesheet\"\n\t\t\t></link>\n\t\t\t<PathfindingVisualizer />\n\t\t</div>\n\t);\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}